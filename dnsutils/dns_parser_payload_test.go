package dnsutils

import (
	"errors"
	"fmt"
	"testing"

	"github.com/dmachard/go-dnscollector/pkgconfig"
	"github.com/miekg/dns"
)

func TestDecodePayload_QueryHappy(t *testing.T) {
	payload := []byte{
		// header
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		// query section
		// name
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Additional records: EDNS OPT with no data, DO = 0, Z=0
		0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		!dm.DNS.Flags.AD ||
		dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "sensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if dm.EDNS.Do != 1 ||
		dm.EDNS.UDPSize != 4096 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DNSRRs.Answers) != 0 ||
		len(dm.DNS.DNSRRs.Nameservers) != 0 ||
		len(dm.DNS.DNSRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}
}
func TestDecodePayload_QueryInvalid(t *testing.T) {
	payload := []byte{
		// header
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		// query section
		// name
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x83, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Additional records: EDNS OPT with no data, DO = 1, Z=0
		0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Errorf("Expected error when parsing payload")
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be marked as malformed")
	}

	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodePayload_AnswerHappy(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "sensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DNSRRs.Answers) != 4 {
		t.Errorf("expected 4 answers, got %d", len(dm.DNS.DNSRRs.Answers))
	}

	for i, ans := range dm.DNS.DNSRRs.Answers {
		expected := DNSAnswer{
			Name:      dm.DNS.Qname,
			Rdatatype: RdatatypeToString(0x0001),
			Class:     "IN", // 0x0001,
			TTL:       300,
			Rdata:     fmt.Sprintf("10.10.1.%d", i+1),
		}
		if expected != ans {
			t.Errorf("unexpected answer (%d). expected %v, got %v", i, expected, ans)
		}
	}

	if dm.EDNS.Do != 0 ||
		dm.EDNS.UDPSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DNSRRs.Nameservers) != 0 ||
		len(dm.DNS.DNSRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}

func TestDecodePayload_AnswerMultipleQueries(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x02, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		// query 1
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// query 2
		0x0a, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,

		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "ensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DNSRRs.Answers) != 4 {
		t.Errorf("expected 4 answers, got %d", len(dm.DNS.DNSRRs.Answers))
	}

	for i, ans := range dm.DNS.DNSRRs.Answers {
		expected := DNSAnswer{
			Name:      "s" + dm.DNS.Qname, // answers have qname from 1st query data, 2nd data is missing 's'
			Rdatatype: RdatatypeToString(0x0001),
			Class:     "IN", // 0x0001,
			TTL:       300,
			Rdata:     fmt.Sprintf("10.10.1.%d", i+1),
		}
		if expected != ans {
			t.Errorf("unexpected answer (%d). expected %v, got %v", i, expected, ans)
		}
	}

	if dm.EDNS.Do != 0 ||
		dm.EDNS.UDPSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DNSRRs.Nameservers) != 0 ||
		len(dm.DNS.DNSRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}

func TestDecodePayload_AnswerInvalid(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0xff,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerInvalidQuery(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x83, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

	// after error has been detected in the query part, we should not parse
	// anything from answers
	if len(dm.DNS.DNSRRs.Answers) != 0 {
		t.Errorf("did not expect answers to be parsed, but there were %d parsed", len(dm.DNS.DNSRRs.Answers))
	}
}

func TestDecodePayload_AnswerInvalidEdns(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, Invalid EDNS Option
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeEdnsOptionTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerInvaliAdditional(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, Invalid RDLENGTH
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerError(t *testing.T) {
	payload := []byte{
		// header
		0xa8, 0x1a, 0x81, 0x83, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01,
		// query
		0x03, 0x66, 0x6f, 0x6f,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Authority section
		// name
		0xc0, 0x10,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x00, 0x3c,
		// RDLENGTH
		0x00, 0x26,
		// RDATA
		// MNAME
		0x03, 0x6e, 0x73, 0x31,
		0xc0, 0x10,
		// RNAME
		0x09, 0x64, 0x6e, 0x73, 0x2d, 0x61,
		0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x10,
		// serial
		0x19, 0xa1, 0x4a, 0xb4,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum
		0x00, 0x00, 0x00, 0x3c,
		// Additianl records, EDNS Option, 0 bytes DO=1, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00,
	}
	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0xa81a ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(3) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "foo.google.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DNSRRs.Answers) != 0 {
		t.Errorf("did not expect any answers, got %d", len(dm.DNS.DNSRRs.Answers))
	}

	if len(dm.DNS.DNSRRs.Nameservers) != 1 {
		t.Errorf("expected 1 authority RR, got %d", len(dm.DNS.DNSRRs.Nameservers))
	}
	expected := DNSAnswer{
		Name:      "google.com",
		Rdatatype: RdatatypeToString(0x0006),
		Class:     "IN", // 0x0001,
		TTL:       60,
		Rdata:     "ns1.google.com dns-admin.google.com 430000820 900 900 1800 60",
	}

	if dm.DNS.DNSRRs.Nameservers[0] != expected {
		t.Errorf("unexpected SOA record parsed, expected %v, git %v", expected, dm.DNS.DNSRRs.Nameservers[0])
	}

	if dm.EDNS.Do != 1 ||
		dm.EDNS.UDPSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

}

func TestDecodePayload_AnswerError_Invalid(t *testing.T) {
	payload := []byte{
		// header
		0xa8, 0x1a, 0x81, 0x83, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01,
		// query
		0x03, 0x66, 0x6f, 0x6f,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Authority section
		// name
		0xc0, 0x10,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x00, 0x3c,
		// RDLENGTH
		0x00, 0x26,
		// RDATA
		// MNAME, invalid offset in pointer
		0x03, 0x6e, 0x73, 0x31,
		0xc0, 0xff,
		// RNAME
		0x09, 0x64, 0x6e, 0x73, 0x2d, 0x61,
		0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x10,
		// serial
		0x19, 0xa1, 0x4a, 0xb4,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum
		0x00, 0x00, 0x00, 0x3c,
		// Additianl records, EDNS Option, 0 bytes DO=1, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00,
	}
	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

}

func TestDecodePayload_AdditionalRRAndEDNS(t *testing.T) {
	// payload containing both addition RR and EDNS, ensure we are
	// able to parse all of them
	payload := []byte{
		0x7b, 0x97, 0x84, 0x0, 0x0, 0x1, 0x0, 0x2,
		0x0, 0x2, 0x0, 0x5, 0xf, 0x6f, 0x63, 0x63,
		0x2d, 0x30, 0x2d, 0x31, 0x35, 0x30, 0x30,
		0x2d, 0x31, 0x35, 0x30, 0x31, 0x1, 0x31,
		0x6, 0x6e, 0x66, 0x6c, 0x78, 0x73, 0x6f,
		0x3, 0x6e, 0x65, 0x74, 0x0, 0x0, 0x1, 0x0,
		0x1, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0,
		0x0, 0x0, 0x1e, 0x0, 0x4, 0x2d, 0x39, 0x24,
		0x97, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0,
		0x0, 0x0, 0x1e, 0x0, 0x4, 0x2d, 0x39, 0x24,
		0x94, 0xc0, 0x1e, 0x0, 0x2, 0x0, 0x1, 0x0,
		0x1, 0x51, 0x80, 0x0, 0x7, 0x1, 0x65, 0x2,
		0x6e, 0x73, 0xc0, 0x1e, 0xc0, 0x1e, 0x0,
		0x2, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0,
		0x4, 0x1, 0x66, 0xc0, 0x5c, 0x0, 0x0, 0x29,
		0x4, 0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0,
		0x5a, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80,
		0x0, 0x4, 0x2d, 0x39, 0x8, 0x1, 0xc0, 0x5a,
		0x0, 0x1c, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0,
		0x10, 0x2a, 0x0, 0x86, 0xc0, 0x20, 0x8, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xc0, 0x6d,
		0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0, 0x4,
		0x2d, 0x39, 0x9, 0x1, 0xc0, 0x6d, 0x0, 0x1c, 0x0, 0x1,
		0x0, 0x1, 0x51, 0x80, 0x0, 0x10, 0x2a, 0x0, 0x86, 0xc0,
		0x20, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("error when deocoding header: %v", err)
	}

	if err := DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("unexpected error while decoding payload: %v", err)
	}

	if len(dm.DNS.DNSRRs.Answers) != 2 || len(dm.DNS.DNSRRs.Nameservers) != 2 ||
		len(dm.DNS.DNSRRs.Records) != 4 || dm.EDNS.UDPSize != 1200 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("unexpected result while parsing payload: %#v", dm.DNS)
	}

}

func TestDecodePayload_Truncated(t *testing.T) {
	payload := []byte{
		// header
		0x77, 0xa0, 0x83, 0x80, 0x00, 0x01, 0x00, 0x23,
		0x00, 0x00, 0x00, 0x00,
		// query
		0x02, 0x41, 0x64, 0x0d,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x02, 0x46, 0x52,
		0x00, 0x00, 0x01, 0x00, 0x01,
		// answer 1
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x01,
		// answer 2
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x02,
		// answer 3
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x03,
		// answer 4
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x04,
		// answer 5
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x05,
		// answer 6
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x06,
		// answer 7
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x07,
		// answer 8
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x08,
		// answer 9
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x09,
		// answer 10
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0a,
		// answer 11
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0b,
		// answer 12
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0c,
		// answer 13
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0d,
		// answer 14
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0e,
		// answer 15
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0f,
		// answer 16
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x10,
		// answer 17
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x11,
		// answer 18
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x12,
		// answer 19
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x13,
		// answer 20
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x14,
		// answer 21
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x15,
		// answer 22
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x16,
		// answer 23
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x17,
		// answer 24
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x18,
		// answer 25
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x19,
		// answer 26
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1a,
		// answer 27
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1b,
		// answer 28
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1c,
		// answer 29
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1d,
		// answer 30
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Error("expected no error on decode")
	}

	if dm.DNS.Flags.TC == false {
		t.Error("truncated answer expected")
	}

	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

// Dynamic query (UPDATE)
func TestDecodePayload_UpdateQuery(t *testing.T) {
	payload := []byte{
		// transaction id
		0x75, 0xa1,
		// Update Query
		0x28, 0x00,
		// 1 zone, O prerequisites, 1 update, 0 additionnal
		0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
		// zone section
		// --> zone name
		0x00,
		// --> zone type SOA
		0x00, 0x06,
		// --> zone class
		0x00, 0x01,
		// update content
		// --> name
		0x14, 0x32, 0x31, 0x30, 0x32, 0x33, 0x31, 0x32, 0x52, 0x4d, 0x53, 0x31, 0x30, 0x4c, 0x32,
		0x30, 0x30, 0x30, 0x34, 0x35, 0x32, 0x00,
		// --> type: A
		0x00, 0x01,
		// --> class ANY
		0x00, 0xff,
		// --> ttl
		0x00, 0x00, 0x00, 0x00,
		// --> data length
		0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Error("expected no error on decode", err)
	}
}

func TestDecodePayload_UpdateQuery_CheckDnstapOperation(t *testing.T) {
	payload := []byte{
		// header
		0xb1, 0x1c, 0x28, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		// zone
		0x00, 0x06, 0x00, 0x01,
		// updates
		0x14, 0x32, 0x31, 0x30, 0x32, 0x33, 0x31, 0x32, 0x52, 0x4d, 0x53, 0x31, 0x30, 0x4c, 0x32,
		0x30, 0x30, 0x30, 0x34, 0x35, 0x32, 0x00, 0x00, 0x01, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, _ := DecodeDNS(payload)
	DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig())

	if dm.DNSTap.Operation != "UPDATE_QUERY" {
		t.Errorf("expect UPDATE_QUERY: get %s", dm.DNSTap.Operation)
	}
}

// Multicast DNS
func TestDecodePayload_MDNSResponseWithNoQuestion(t *testing.T) {
	payload := []byte{
		0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x0b, 0x5f, 0x67, 0x6f,
		0x6f, 0x67, 0x6c, 0x65, 0x63, 0x61, 0x73, 0x74, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x05, 0x6c, 0x6f,
		0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x35, 0x32, 0x53,
		0x48, 0x49, 0x45, 0x4c, 0x44, 0x2d, 0x41, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2d, 0x54, 0x56,
		0x2d, 0x30, 0x66, 0x33, 0x31, 0x30, 0x63, 0x32, 0x63, 0x39, 0x66, 0x62, 0x62, 0x64, 0x61, 0x64,
		0x64, 0x31, 0x39, 0x39, 0x30, 0x30, 0x38, 0x31, 0x61, 0x61, 0x66, 0x35, 0x37, 0x65, 0x66, 0x38,
		0x33, 0xc0, 0x0c, 0xc0, 0x2e, 0x00, 0x10, 0x80, 0x01, 0x00, 0x00, 0x11, 0x94, 0x00, 0xd2, 0x23,
		0x69, 0x64, 0x3d, 0x30, 0x66, 0x33, 0x31, 0x30, 0x63, 0x32, 0x63, 0x39, 0x66, 0x62, 0x62, 0x64,
		0x61, 0x64, 0x64, 0x31, 0x39, 0x39, 0x30, 0x30, 0x38, 0x31, 0x61, 0x61, 0x66, 0x35, 0x37, 0x65,
		0x66, 0x38, 0x33, 0x23, 0x63, 0x64, 0x3d, 0x42, 0x35, 0x35, 0x36, 0x39, 0x31, 0x37, 0x42, 0x30,
		0x36, 0x33, 0x38, 0x46, 0x46, 0x32, 0x43, 0x35, 0x30, 0x45, 0x42, 0x43, 0x33, 0x34, 0x34, 0x41,
		0x45, 0x35, 0x31, 0x46, 0x39, 0x43, 0x37, 0x03, 0x72, 0x6d, 0x3d, 0x05, 0x76, 0x65, 0x3d, 0x30,
		0x35, 0x14, 0x6d, 0x64, 0x3d, 0x53, 0x48, 0x49, 0x45, 0x4c, 0x44, 0x20, 0x41, 0x6e, 0x64, 0x72,
		0x6f, 0x69, 0x64, 0x20, 0x54, 0x56, 0x12, 0x69, 0x63, 0x3d, 0x2f, 0x73, 0x65, 0x74, 0x75, 0x70,
		0x2f, 0x69, 0x63, 0x6f, 0x6e, 0x2e, 0x70, 0x6e, 0x67, 0x09, 0x66, 0x6e, 0x3d, 0x53, 0x48, 0x49,
		0x45, 0x4c, 0x44, 0x09, 0x63, 0x61, 0x3d, 0x34, 0x36, 0x33, 0x33, 0x36, 0x35, 0x04, 0x73, 0x74,
		0x3d, 0x31, 0x0f, 0x62, 0x73, 0x3d, 0x46, 0x41, 0x38, 0x46, 0x46, 0x36, 0x46, 0x30, 0x45, 0x30,
		0x38, 0x38, 0x04, 0x6e, 0x66, 0x3d, 0x31, 0x09, 0x63, 0x74, 0x3d, 0x30, 0x39, 0x31, 0x43, 0x44,
		0x34, 0x13, 0x72, 0x72, 0x3d, 0x41, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x4e, 0x61, 0x74, 0x69,
		0x76, 0x65, 0x41, 0x70, 0x70, 0x0b, 0x72, 0x73, 0x3d, 0x4a, 0x65, 0x6c, 0x6c, 0x79, 0x66, 0x69,
		0x6e, 0xc0, 0x2e, 0x00, 0x21, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x2d, 0x00, 0x00, 0x00,
		0x00, 0x1f, 0x49, 0x24, 0x30, 0x66, 0x33, 0x31, 0x30, 0x63, 0x32, 0x63, 0x2d, 0x39, 0x66, 0x62,
		0x62, 0x2d, 0x64, 0x61, 0x64, 0x64, 0x2d, 0x31, 0x39, 0x39, 0x30, 0x2d, 0x30, 0x38, 0x31, 0x61,
		0x61, 0x66, 0x35, 0x37, 0x65, 0x66, 0x38, 0x33, 0xc0, 0x1d, 0xc1, 0x53, 0x00, 0x1c, 0x80, 0x01,
		0x00, 0x00, 0x00, 0x78, 0x00, 0x10, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x3e,
		0x51, 0x15, 0x8e, 0x6d, 0xa2, 0x96,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Error("expected no error on decode", err)
	}
}

// Rcode should not be set on query
func TestDecodePayload_Query_NoRcode(t *testing.T) {
	payload := []byte{
		// transaction ID
		0xb1, 0x17,
		// flags
		0x01, 0x00,
		// questions
		0x00, 0x01,
		// answer
		0x00, 0x00,
		// authority
		0x00, 0x00,
		// additional
		0x00, 0x00,
		// queries
		0x00, 0x00, 0x06, 0x00, 0x01,
	}

	dm := DNSMessage{}
	dm.Init()
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	// decode header and paylo
	header, _ := DecodeDNS(payload)
	DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig())

	// check the rcode
	if dm.DNS.Rcode != "-" {
		t.Errorf("invalid rcode: %s", dm.DNS.Rcode)
	}
}

func TestDecodePayload_Response_Extended_Rcode(t *testing.T) {
	// issue #1027. The dns.Rcode field should contain the full RCODE, including the extended RCode
	// This packet has the RCODE XYRRSET (7) in the header, and the upper 8 bits in the
	// Extended RCODE set to 16 (1<<4), which is RCODE 23, BADCOOKIE.
	// We don't really stuff a cookie in the response, as that is not the point of this test :).
	payload := []byte{
		// header, RCODE set to XYRRSET (7)
		0xa8, 0x1a, 0x81, 0x07, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01,
		// query
		0x03, 0x66, 0x6f, 0x6f,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Authority section
		// name
		0xc0, 0x10,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x00, 0x3c,
		// RDLENGTH
		0x00, 0x26,
		// RDATA
		// MNAME
		0x03, 0x6e, 0x73, 0x31,
		0xc0, 0x10,
		// RNAME
		0x09, 0x64, 0x6e, 0x73, 0x2d, 0x61,
		0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x10,
		// serial
		0x19, 0xa1, 0x4a, 0xb4,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum
		0x00, 0x00, 0x00, 0x3c,
		// Additional records, EDNS Record
		// Root label
		0x00,
		// Tupe field, OPT (41)
		0x00, 0x29,
		// Class, UDP payload size
		0x04, 0xd0,
		// TTL, Extended RCODE and flags
		// Extended RCODE (1, but parsed as the 5th bit, so 16)
		0x01,
		// EDNS version 0
		0x00,
		// Flags, DO=1
		0x80, 0x00,
		// RDLEN (0)
		0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.Init()
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	// decode header and paylo
	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}
	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}
	if dm.DNS.Rcode != RcodeToString(dns.RcodeBadCookie) {
		t.Errorf("did not expect RCode to be %s", dm.DNS.Rcode)
	}
}
